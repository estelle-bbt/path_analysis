name_ID=unique(ID_full),
nb_visit=n(),
duration=sum(duration,na.rm=T)) |> # to calculate flower age (visits needed to be sequentially arrange, independently of the pollinators)
mutate(ID_full=name_ID) |>
pivot_wider(values_from=name_ID,names_from=name_ID,names_prefix="newID_",values_fn = list(name_ID = ~ 1), values_fill = list(name_ID = 0)) |>
mutate(across(starts_with("newID"),~ifelse(duplicated(cumsum(.)),NA,cumsum(.)))) |>
rowwise() |>
mutate(no_contact_with_id=sum(across(starts_with("newID")),na.rm=T)) |>
select(!starts_with("newID")) |>
arrange(session,start)
dt_contact
dt_contact <- dto |>
mutate(ID_full=paste0(session,".",ifelse(ID==10,10,paste0("0",ID)))) |>
group_by(session,people) |>
mutate(consecutive_contact=consecutive_id(ID_full)) |>
group_by(session,people,consecutive_contact) |>
summarise(start=min(time),
name_ID=unique(ID_full),
nb_visit=n(),
duration=sum(duration,na.rm=T)) |> # to calculate flower age (visits needed to be sequentially arrange, independently of the pollinators)
mutate(id=name_ID) |>
pivot_wider(values_from=name_ID,names_from=name_ID,names_prefix="newID_",values_fn = list(name_ID = ~ 1), values_fill = list(name_ID = 0)) |>
mutate(across(starts_with("newID"),~ifelse(duplicated(cumsum(.)),NA,cumsum(.)))) |>
rowwise() |>
mutate(no_contact_with_id=sum(across(starts_with("newID")),na.rm=T)) |>
select(!starts_with("newID")) |>
reorder(session,people,id)
dt_contact <- dto |>
mutate(ID_full=paste0(session,".",ifelse(ID==10,10,paste0("0",ID)))) |>
group_by(session,people) |>
mutate(consecutive_contact=consecutive_id(ID_full)) |>
group_by(session,people,consecutive_contact) |>
summarise(start=min(time),
name_ID=unique(ID_full),
nb_visit=n(),
duration=sum(duration,na.rm=T)) |> # to calculate flower age (visits needed to be sequentially arrange, independently of the pollinators)
mutate(id=name_ID) |>
pivot_wider(values_from=name_ID,names_from=name_ID,names_prefix="newID_",values_fn = list(name_ID = ~ 1), values_fill = list(name_ID = 0)) |>
mutate(across(starts_with("newID"),~ifelse(duplicated(cumsum(.)),NA,cumsum(.)))) |>
rowwise() |>
mutate(no_contact_with_id=sum(across(starts_with("newID")),na.rm=T)) |>
select(!starts_with("newID")) |>
relocate(session,people,id)
dt_contact
dt_contact_id <- dt_contact |>
group_by(session,name_ID) |>
summarize(nb_contact=max(no_contact_with_id),
nb_visit=sum(nb_visit),
dur_visit=sum(duration,na.rm=T)) |>
left_join(dt_contact |>
group_by(session) |>
summarize(max_oMS = unique(id)))
dt_contact_id <- dt_contact |>
group_by(session,id) |>
summarize(nb_contact=max(no_contact_with_id),
nb_visit=sum(nb_visit),
dur_visit=sum(duration,na.rm=T)) |>
left_join(dt_contact |>
group_by(session) |>
summarize(max_oMS = unique(id)))
dt_contact |>
group_by(session,id) |>
summarize(nb_contact=max(no_contact_with_id),
nb_visit=sum(nb_visit),
dur_visit=sum(duration,na.rm=T))
dt_contact |>
group_by(session) |>
summarize(max_oMS = unique(id))
dt_contact
dt_contact_id <- dt_contact |>
group_by(session,id) |>
summarize(nb_contact=max(no_contact_with_id),
nb_visit=sum(nb_visit),
dur_visit=sum(duration,na.rm=T)) |>
left_join(dt_contact |>
group_by(session) |>
summarize(max_oMS = n_distinct(id)))
dt_contact_id
View(dt_contact_id)
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
??pivot_wider
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
tar_load(dt_obs)
targets::tar_load(dt_obs)
targets::tar_load(dt_obs)
targets::tar_load(data_obs)
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
## Configuration de git ----
gert::git_config_global()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
targets::tar_load(data_contact)
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
targets::tar_load(data_contact)
data_contact$dt_contact
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#------------------------------#
# HOW TO ESTIMATE EASILY oMS ? #
#------------------------------#
# LIBRARIES ---------------------------------------------------------------
library(tidyverse)
library(lme4)
library(FactoMineR)
library(car)
library(lmerTest)
library(ggpmisc)
# PREPARE DATA ---------------------------------------------------
#### MAIN FILE ####
setwd("~/Documents/ISEM/1_ABPOLL/Analyses/14_ESTIMATE_oMS/")
dti <- read.table("~/Documents/ISEM/1_ABPOLL/Data/3_COMPIL/TABLES/data_ABPOLL_ID_resume.txt",head=T) %>%
mutate(poll_treat_factor=as.factor(case_when(poll_treat==1~"low",
poll_treat==2~"medium",
TRUE~"high"))) %>%
mutate(poll_treat_factor=fct_relevel(poll_treat_factor, c("low","medium","high"))) %>%
mutate(prop_self=SR_self/(SR_self+SR_fem_out+SR_mal_out),
gam_ov_proxy=nb_flo*nbOv_mean,
SR_out=SR_fem_out+SR_mal_out) %>%
mutate(mean_nb_visit_per_flower=nb_visit/nb_dist_vis)
dto <- read.table("~/Documents/ISEM/1_ABPOLL/Analyses/2_oMS/obs_ABPOLL.txt",head=T) %>%
mutate(ttt=as.factor(case_when(grepl("FA",session)~"1_low",
grepl("MO",session)~"2_medium",
TRUE~"3_high")))
# COMPLEX ANALYSES : NEEDED TO A GLOBAL UNDERSTANDING  ---------------------------------------------------------------------
# il faut partir d'un jeu de données hypothétique, comme on aurait pu avoir si on avait fait
# les choses plus simplement
# et en parallèle, on a les vrais oMS calculé à partir des séquences de visites par fleur
# on se fixe d'abord sur un carry-over (10 ?) et on regarde comment on peut faire
# pour avoir une meilleure estimation du vrai oMS
# faire pour les deux fonctions sexuelles
# en fait au lieu de travailler sur le nombre de visites à l'échelle de la fleur (qu'on aurait pas dans un protocole plus simple)
# on voudrait travailler sur la durée des visites totales par individu à chaque fois qu'il est visité
# donc on voudrait avoir une idée de la relation durée ~ nombre de visites
dto_age_flow <- dto %>%
arrange(session,time) %>% # to calculate flower age (visits needed to be sequentially arrange, independently of the pollinators)
pivot_wider(values_from=id_flow_full,names_from=id_flow_full,names_prefix="newFlo_",values_fn = list(id_flow_full = ~ 1), values_fill = list(id_flow_full = 0)) %>%
mutate(across(starts_with("newFlo"),~ifelse(duplicated(cumsum(.)),NA,cumsum(.)))) %>%
rowwise() %>%
mutate(flower_age=sum(across(starts_with("newFlo")),na.rm=T)-1) %>%
select(!starts_with("newFlo")) %>%
mutate(id_flow_full=paste0(ID_full,"_",noHp,"_",flow)) %>%
group_by(session,people) %>%
mutate(no_visit=1:n())
mod_dur_age_flow <- lmer(data=dto_age_flow,duration~flower_age+(1|session)+(1|session:ID_full)+(1|ID_full:id_flow_full)+(1|session:people))
Anova(mod_dur_age_flow)
summary(mod_dur_age_flow)
# plus une fleur a été visitée, moins les visites sont longues
dto_age_ID <- dto %>%
arrange(session,time) %>% # to calculate flower age (visits needed to be sequentially arrange, independently of the pollinators)
pivot_wider(values_from=ID_full,names_from=ID_full,names_prefix="newID_",values_fn = list(ID_full = ~ 1), values_fill = list(ID_full = 0)) %>%
mutate(across(starts_with("newID"),~ifelse(duplicated(cumsum(.)),NA,cumsum(.)))) %>%
rowwise() %>%
mutate(ID_age=sum(across(starts_with("newID")),na.rm=T)-1) %>%
select(!starts_with("newID")) %>%
mutate(ID_full=paste0(session,".",ifelse(ID==10,10,paste0("0",ID)))) %>%
group_by(session,people) %>%
mutate(no_visit=1:n())
mod_dur_age_ID <- lmer(data=dto_age_ID,duration~ID_age+(1|session)+(1|session:ID_full)+(1|ID_full:id_flow_full)+(1|session:people))
Anova(mod_dur_age_ID)
summary(mod_dur_age_ID)
# on retrouve le même patron à l'échelle individuelle : plus un individu a été visité, moins les visites sont longues
dto_boot_level <- dto_age_ID %>%
group_by(session,people) %>%
mutate(consecut=consecutive_id(ID_full)) %>%
group_by(session,people,consecut) %>%
summarise(start=min(time),
name_ID=unique(ID_full),
length=n(),
duration=sum(duration,na.rm=T)) %>% # to calculate flower age (visits needed to be sequentially arrange, independently of the pollinators)
mutate(ID_full=name_ID) %>%
pivot_wider(values_from=name_ID,names_from=name_ID,names_prefix="newID_",values_fn = list(name_ID = ~ 1), values_fill = list(name_ID = 0)) %>%
mutate(across(starts_with("newID"),~ifelse(duplicated(cumsum(.)),NA,cumsum(.)))) %>%
rowwise() %>%
mutate(ID_no_boot=sum(across(starts_with("newID")),na.rm=T)-1) %>%
select(!starts_with("newID")) %>%
mutate(ID=substr(ID_full,7,8))
# il y a un decalage entre start et duration mais c'est normal -> il y a pas les temps de vols inter individu
# on regarde maintenant à l'échelle du boot de visites donc la relation entre
# la durée du boot et le nombre de visites en son sein + le nombre de fois qu'il a été visité auparavant
mod_dur_boot <- lmer(data=dto_boot_level,duration~length*ID_no_boot+(1|session)+(1|session:ID_full)+(1|session:people))
Anova(mod_dur_boot)
summary(mod_dur_boot)
# donc :
# - plus il y a de visites dans un boot, plus la durée est grande (normal)
# - plus un individu a été déjà visité dans des boots précédents, moins les visites sont longues puisque ça a un effet moins positif sur la durée totale
# on regarde en travaillant directement sur la moyenne des visites :
dto_boot_level <- dto_boot_level %>%
mutate(mean_dur_visit=duration/length)
mod_dur_boot_mean <- lmer(data=dto_boot_level,mean_dur_visit~ID_no_boot+(1|session)+(1|session:ID_full)+(1|session:people))
Anova(mod_dur_boot_mean)
summary(mod_dur_boot_mean)
# la durée moyenne des visites diminue bien en tendance
# donc si un individu est visité plusieurs fois à travers différents boots, les derniers boots représentent
# un accès moindre à des partenaires sexuels dans la séquence de visites a durée égale par rapport aux premiers boots
# car les pollinisateurs restent plus sur place -> les individus visités plus loin en amont ou en aval de la séquence sont moins atteints
ggplot(data=dto_boot_level,aes(x=as.factor(ID_no_boot),y=mean_dur_visit)) +
geom_boxplot()
# et en regardant par individu :
ggplot(data=dto_boot_level,aes(x=as.factor(ID_no_boot),y=mean_dur_visit,colour=ID)) +
facet_grid(~session) +
geom_boxplot()
# il semble en effet qu'il y ait des individus pour lesquels les visites sont en moyenne plus longues :
ggplot(data=dto_boot_level,aes(x=as.factor(ID_no_boot),y=mean_dur_visit,colour=ID)) +
facet_grid(ID~session) +
geom_boxplot()
# on regarde si l'identité de l'individu joue sur les différentes variables de visites :
mod_dur_boot_ID <- glmer(data=dto_boot_level,ID_no_boot~ID_full+(1|session)+(1|session:people),family="poisson")
performance::check_overdispersion(mod_dur_boot_ID) # ça va pas
Anova(mod_dur_boot_ID)
summary(mod_dur_boot_ID)
# il y a des individus qui sont plus visités que d'autres à travers le nombre de boot
dto_boot_level <- dto_boot_level %>%
left_join(dti %>%
select(ID_full,nb_flo_open)) %>%
mutate(session_people=paste0(session,"_",people)) %>%
mutate(ID_no_boot_new=ID_no_boot+1)
# et sur le nb de fleurs ?
mod_dur_boot_nb_flo <- glmer(data=dto_boot_level,ID_no_boot_new~nb_flo_open+(1|session)++(1|session:ID_full)+(1|session:people),family="poisson")
performance::check_overdispersion(mod_dur_boot_nb_flo)
Anova(mod_dur_boot_nb_flo)
summary(mod_dur_boot_nb_flo)
# + de fleurs = + de boot
# et regarder maintenant effet nb de fleurs sur durée au sein d'un boot
mod_dur_boot_mean_nb_flo <- lmer(data=dto_boot_level,mean_dur_visit~ID_no_boot*nb_flo_open*length+(1|session)+(1|session:ID_full)+(1|session:people))
Anova(mod_dur_boot_mean_nb_flo)
summary(mod_dur_boot_mean_nb_flo)
mod_dur_boot_mean_ID <- lmer(data=dto_boot_level,length~ID_full*ID_no_boot+(1|session)+(1|session:people))
Anova(mod_dur_boot_mean_ID)
summary(mod_dur_boot_mean_ID)
mod_dur_boot_mean_ID <- lmer(data=dto_boot_level,mean_dur_visit~ID_full*ID_no_boot+(1|session)+(1|session:people))
Anova(mod_dur_boot_mean_ID)
summary(mod_dur_boot_mean_ID)
# par contre les propriétés de ces visites restent inchangées entre individus (mais on est limité niveau ddl pour tester ça)
# donc ça voudrait dire qu'on peut tirer des grandes règles pour le calcul d'oMS qui sont indépendants des individus, de leur attractivité globale
# ces règles s'appliquent à tous les individus et seraient basées sur :
# 1) l'ordre des visites
# 2) la présence/absence de soi-même dans les séquences de visites (selfing exclude)
# 3) le nombre de boot par individu (qui joue aussi sur...)
# 4) la durée des visites par individu
# on définit une relation durée du boot ~ nombre de visites en son sein pour qualifier un carry-over et avoir l'oMS
# donc on veut définir des pentes nombre de visite ~ durée des visites qui changeraient en fonction du numéro de boot
# d'abord on se fixe dans un cas simple -> c'est la première fois qu'un individu est visité
# est-ce qu'on a une relation linéaire ou plutôt quadratique, avec au sein d'un boot aussi plus de visites = des visites moins longues ?
# c'est probablement le cas si les mêmes fleurs sont revisitées au sein du boot quand il y a beaucoup de visites (cf modèle age flower)
# on regarde sur sous jeu de données avec que les premières fois où les individus sont visités :
dto_boot_level_first <- dto_boot_level %>%
filter(ID_no_boot==0) %>%
mutate(length2=length*length)
# relation linéaire ou quadratique avec seuil ?
mod_first <- lmer(data=dto_boot_level_first,duration~length+length2+(1|session)+(1|session:people))
Anova(mod_first)
summary(mod_first)
ggplot(dto_boot_level_first,aes(x=length,y=duration)) +
geom_point() +
geom_smooth(method="gam")
# okay donc en effet ce serait plutôt le patron inverse, m&ais on dirait que c'est majoritairement drivé
# par les deux points > 40
# on regarde sans ce que ça donne
dto_boot_level_first <- dto_boot_level_first %>%
filter(length<40)
# relation linéaire ou quadratique avec seuil ?
mod_first <- lmer(data=dto_boot_level_first,duration~length+length2+(1|session)+(1|session:people))
Anova(mod_first)
summary(mod_first)
# oui c'est vraiment ces deux points qui drivaient le truc
# on reste donc sur une relation linéaire simple en l'état
# on vérifie ensuite sur les boots suivants, jusqu'à combien ?
ggplot(dto_boot_level,aes(x=ID_no_boot)) +
geom_histogram()
# disons les 5 premiers :
dim(dto_boot_level)
dto_boot_level %>%
filter(ID_no_boot<5)
(719*100)/859
# oui ça représente 83% des cas
# second boot
dto_boot_level_second <- dto_boot_level %>%
filter(ID_no_boot==1) %>%
mutate(length2=length*length)
mod_second <- lmer(data=dto_boot_level_second,duration~length+length2+(1|session)+(1|session:people))
Anova(mod_second)
summary(mod_second)
ggplot(dto_boot_level_second,aes(x=length,y=duration)) +
geom_point() +
geom_smooth(method="gam")
# two outliers
dto_boot_level_second <- dto_boot_level_second %>%
filter(length<30)
mod_second <- lmer(data=dto_boot_level_second,duration~length+length2+(1|session)+(1|session:people))
Anova(mod_second)
summary(mod_second)
ggplot(dto_boot_level_second,aes(x=length,y=duration)) +
geom_point() +
geom_smooth(method="gam")
# mouais okay c'est pas obvious (d'autant plus que si je retire que le premier outlier, négatif)
# third boot
dto_boot_level_third <- dto_boot_level %>%
filter(ID_no_boot==2) %>%
mutate(length2=length*length)
mod_third <- lmer(data=dto_boot_level_third,duration~length+length2+(1|session)+(1|session:people))
Anova(mod_third)
summary(mod_third)
ggplot(dto_boot_level_third,aes(x=length,y=duration)) +
geom_point() +
geom_smooth(method="gam")
# fourth boot
dto_boot_level_fourth <- dto_boot_level %>%
filter(ID_no_boot==3) %>%
mutate(length2=length*length)
mod_fourth <- lmer(data=dto_boot_level_fourth,duration~length+length2+(1|session)+(1|session:people))
Anova(mod_fourth)
summary(mod_fourth)
ggplot(dto_boot_level_fourth,aes(x=length,y=duration)) +
geom_point() +
geom_smooth(method="gam")
# fifth boot
dto_boot_level_fifth <- dto_boot_level %>%
filter(ID_no_boot==4) %>%
mutate(length2=length*length)
mod_fifth <- lmer(data=dto_boot_level_fifth,duration~length+length2+(1|session)+(1|session:people))
Anova(mod_fifth)
summary(mod_fifth)
ggplot(dto_boot_level_fifth,aes(x=length,y=duration)) +
geom_point() +
geom_smooth(method="gam")
# bon je pense qu'on peut dire que c'est des relations linéaires simples au sein de chaque boot
# on estime maintenant les beta:
mod_dur_boot <- lmer(data=dto_boot_level,duration~length*ID_no_boot+(1|session)+(1|session:ID_full)+(1|session:people))
Anova(mod_dur_boot)
summary(mod_dur_boot)
# est-ce qu'i faut pas plutot mettre le numéro de boot en factor pour voir comment ça change entre niveau ?
mod_dur_boot <- lmer(data=dto_boot_level,duration~length*as.factor(ID_no_boot)+(1|session)+(1|session:ID_full)+(1|session:people))
Anova(mod_dur_boot)
summary(mod_dur_boot)
# bouarf ça donne quand même l'impression que plus le boot est loin plus ça diminue, on va plutôt mettre ça en linéaire comme avant pour simplifier
mod_dur_boot <- lmer(data=dto_boot_level,duration~length*ID_no_boot+(1|session)+(1|session:ID_full)+(1|session:people))
Anova(mod_dur_boot)
summary(mod_dur_boot)
# donc : + 1 visite c'est 9.63 secondes en plus (c'est exacerbé car ça comprendre un peu de temps de vol, quand les visites étaient très proches))
# mais c'est pas grave car ces temps seront aussi inclu quand on aura les visites totales par individu, donc c'est représentatif
# mais + 1 boot c'est à chaque fois -1.26 sur ce premier effet
# bon très bien, maintenant on veut avoir la corrélation dans l'autre sens :
# nous on aura les durées et le nombre de boot uniquement
mod_length_boot <- glmer(data=dto_boot_level,length~duration*ID_no_boot+(1|session)+(1|session:ID_full)+(1|session:people)+(1|session_people),family="poisson")
performance::check_overdispersion(mod_length_boot)
mod_length_boot <- glmmTMB(data=dto_boot_level,length~duration*ID_no_boot+(1|session)+(1|session:ID_full)+(1|session:people),family=nbinom2())
targets::tar_load(data_contact)
??glmmTMB
library(glmmTMB)
mod_length_boot <- glmmTMB(data=dto_boot_level,length~duration*ID_no_boot+(1|session)+(1|session:ID_full)+(1|session:people),family=nbinom2())
performance::check_overdispersion(mod_length_boot)
Anova(mod_length_boot)
summary(mod_length_boot)
dto_boot_level <- dto_boot_level %>%
bind_cols(predictions=predict(mod_length_boot))
ggplot(dto_boot_level,aes(x=length,y=predictions)) +
geom_point() +
geom_smooth()
hill_number_shannon <- function(pere_freqs) {
prop <- pere_freqs / sum(pere_freqs)
shannon <- -sum(prop * log(prop))
exp(shannon)
}
hill_number_simpson <- function(pere_freqs) {
Q = sum((pere_freqs / sum(pere_freqs))^2)
# gini_simpson <- 1-Q
simpson <- Q
1/(Q)
}
cols <- c("co10", "co1", "co5", "co300")
data_res_ID <- dti %>%
select(session, ID_full, nb_flo_open, nb_poll_focal,
!!!syms(paste0("import_nb_part_ID_out_", cols)),
!!!syms(paste0("export_nb_part_ID_out_", cols))) %>%
rename_with(~ gsub("import_nb_part_ID_out_", "oMS_fem_", .x), starts_with("import_")) %>%
rename_with(~ gsub("export_nb_part_ID_out_", "oMS_mal_", .x), starts_with("export_"))
dto_boot_level_clean <- dto_boot_level %>%
select(session,ID_full,people,start,consecut,duration,ID_no_boot_new)
dto_boot_level_res_wbee_ID <- dto_boot_level_clean %>%
group_by(session,ID_full,people) %>%
summarize(nb_boot=max(ID_no_boot_new),
dur_boot=sum(duration,na.rm=T))
dto_boot_level_res_wbee_bee <- dto_boot_level_clean %>%
group_by(session,people) %>%
summarize(nb_boot_bee=max(consecut),
dur_boot_bee=sum(duration,na.rm=T),
nb_ID_bee=n_distinct(ID_full))
# on ne saura probablement pas identité de la bee... simplifier encore
dto_boot_level_res_wobee_ID <- dto_boot_level_res_wbee_ID %>%
group_by(session,ID_full) %>%
summarize(nb_boot=sum(nb_boot),
dur_boot=sum(dur_boot,na.rm=T))
dto_boot_level_res_wobee_ID
dto_boot_level_res_wobee_bee <- dto_boot_level_res_wbee_bee %>%
group_by(session) %>%
summarize(nb_boot_bee=sum(nb_boot_bee),
dur_boot_bee=sum(dur_boot_bee,na.rm=T)) %>%
# for nb of distinct partner visited need to known the identity
left_join(dto_boot_level_clean %>%
group_by(session) %>%
summarize(nb_ID_bee=n_distinct(ID_full),
hill_number_shannon_bee=hill_number_shannon(table(ID_full)),
hill_number_simpson_bee=hill_number_simpson(table(ID_full)),
))
dto_boot_level_res_wbee_bee
dto_boot_level_res_wobee_bee
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
library(targets)
tar_load(data_id)
View(data_id)
tar_load-data_contact
tar_load(data_contact)
data_contact$dt_contact_id
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
#' Project builder
## Install Dependencies (listed in DESCRIPTION) ----
remotes::install_deps(upgrade = "never")
## Run Project ----
targets::tar_make()
